(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{488:function(t,e,n){"use strict";n.r(e);var s=n(2),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("hr"),t._v(" "),e("h2",[t._v("useEffect")]),t._v("\n用于在函数组件中执行副作用操作。\n用法：useEffect(effectFn,deps)可以模拟渲染后、更新后、销毁这三个动作\n"),e("h2",[t._v("useLayoutEffect")]),t._v("\n类似于useEffect，但在DOM更新之后同步执行。\n"),e("h2",[t._v("useState")]),t._v("\n用于给函数组件提供数据，定义状态变量。\n语法：const [state, setState] = React.useState(initialstate) 返回一个state，以及更新state的函数。\n在初始渲染期间，返回的状态state与传入的第一个参数initialstate值相同，setState函数用于更新state。\n"),e("h2",[t._v("useReducer")]),t._v("\n用于在函数组件中使用Reducer模式来管理状态。\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\nreducer参数：用于指定如何更新状态。是一个函数（state，action） => newState 返回新的state\ninitialArg参数：用于计算初始状态的值，\ninit参数：是可选参数，是一个函数，返回初始值，（initialArg） => initState 返回初始state（如果init指定，那么初始值以init函数返回的值为准。init未指定则以initialArg参数为主\n"),e("h2",[t._v("useContext")]),t._v("\n用于在函数组件中访问React的上下文。\n"),e("h2",[t._v("useRef")]),t._v("\n用于在函数组件中创建可变的引用。\n"),e("h2",[t._v("useMemo")]),t._v("\n用于在函数组件中缓存计算的值。\n只有依赖项改变的时候才会触发，否则就拿缓存的值【相当于vue的computed属性】\n"),e("h2",[t._v("useCallback")]),t._v("\n用于在函数组件中缓存函数，原理就是在依赖改变的情况下，返回新的函数地址，依赖不改变的情况下返回旧的函数地址。\n"),e("h2",[t._v("useImperativeHandle")]),t._v("\n用于在函数组件中自定义外部组件实例的暴露。\n"),e("h2",[t._v("useDebugValue")]),t._v("\n用于在自定义Hooks中显示自定义的调试值。")])}),[],!1,null,null,null);e.default=a.exports}}]);